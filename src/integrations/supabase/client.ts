
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://zrpmghqlhxjwxceqihfg.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpycG1naHFsaHhqd3hjZXFpaGZnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE3NDQwNDAsImV4cCI6MjA1NzMyMDA0MH0.ZKf1u7-l6oqHCQ-J-U_FG34YcXCEYD0wlyMTQakTmnQ";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true, // Enable this to detect auth in URL
    flowType: 'pkce', // Use PKCE flow for more secure authentication
    storageKey: 'epu_supabase_auth', // Use a specific key for storage to avoid conflicts
  },
  global: {
    headers: {
      'Cache-Control': 'no-cache',
      'Pragma': 'no-cache',
    },
    fetch: (url, options) => {
      const timeout = 10000; // Giảm timeout xuống 10 giây để tăng trải nghiệm người dùng
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      return fetch(url, {
        ...options,
        signal: controller.signal
      }).finally(() => clearTimeout(timeoutId));
    }
  },
  realtime: {
    params: {
      eventsPerSecond: 10
    }
  },
  db: {
    schema: 'public'
  }
});

// Helper functions for test data
export const fetchTestQuestions = async (chapterId: string) => {
  try {
    const { data, error } = await supabase
      .from('chapter_tests')
      .select('*')
      .eq('chapter_id', chapterId)
      .order('created_at', { ascending: true });
      
    if (error) throw error;
    return data || [];
  } catch (error) {
    console.error('Error fetching test questions:', error);
    return [];
  }
};

export const saveTestResult = async (
  userId: string, 
  courseId: string,
  chapterId: string,
  lessonId: string,
  score: number, 
  totalQuestions: number
) => {
  try {
    // Calculate percentage
    const percentage = Math.round((score / totalQuestions) * 100);
    const passed = percentage >= 70;
    
    // First update the lesson progress
    await supabase
      .from('user_lesson_progress')
      .upsert({
        user_id: userId,
        lesson_id: lessonId,
        course_id: courseId,
        completed: passed,
        last_position: JSON.stringify({
          score,
          total: totalQuestions,
          percentage
        }),
        completed_at: passed ? new Date().toISOString() : null,
        updated_at: new Date().toISOString()
      });
    
    // Then update the overall course progress
    await updateCourseProgress(userId, courseId);
    
    return { success: true };
  } catch (error) {
    console.error('Error saving test result:', error);
    return { success: false, error };
  }
};

// Add function to update course progress
export const updateCourseProgress = async (userId: string, courseId: string) => {
  try {
    // First get total lesson count for this course
    const { data: lessons, error: lessonError } = await supabase
      .from('lessons')
      .select('id')
      .eq('course_id', courseId);
      
    if (lessonError) throw lessonError;
    const totalLessons = lessons?.length || 0;
    
    if (totalLessons === 0) return { success: true };
    
    // Get completed lessons
    const { data: progress, error: progressError } = await supabase
      .from('user_lesson_progress')
      .select('id')
      .eq('user_id', userId)
      .eq('course_id', courseId)
      .eq('completed', true);
      
    if (progressError) throw progressError;
    const completedLessons = progress?.length || 0;
    
    // Calculate percentage
    const progressPercentage = Math.round((completedLessons / totalLessons) * 100);
    
    // Update user_courses table
    const { error: updateError } = await supabase
      .from('user_courses')
      .upsert({
        user_id: userId,
        course_id: courseId,
        progress_percentage: progressPercentage,
        last_accessed: new Date().toISOString()
      });
      
    if (updateError) throw updateError;
    
    return { success: true, progress: progressPercentage };
  } catch (error) {
    console.error('Error updating course progress:', error);
    return { success: false, error };
  }
};

// Function to track user position in a lesson
export const saveLessonProgress = async (
  userId: string,
  courseId: string,
  lessonId: string,
  position: any, // Could be time position for video, or scroll position, etc.
  completed: boolean = false
) => {
  try {
    // Update the lesson progress
    const { error } = await supabase
      .from('user_lesson_progress')
      .upsert({
        user_id: userId,
        lesson_id: lessonId,
        course_id: courseId,
        completed,
        last_position: JSON.stringify(position),
        completed_at: completed ? new Date().toISOString() : null,
        updated_at: new Date().toISOString()
      });
      
    if (error) throw error;
    
    // If the lesson is marked as completed, update overall course progress
    if (completed) {
      await updateCourseProgress(userId, courseId);
    }
    
    return { success: true };
  } catch (error) {
    console.error('Error saving lesson progress:', error);
    return { success: false, error };
  }
};

// Function to get the user's progress in a course
export const getCourseProgress = async (userId: string, courseId: string) => {
  try {
    const { data, error } = await supabase
      .from('user_courses')
      .select('progress_percentage, last_accessed')
      .eq('user_id', userId)
      .eq('course_id', courseId)
      .single();
      
    if (error && error.code !== 'PGRST116') throw error; // PGRST116 means no rows returned
    
    return {
      success: true,
      progress: data?.progress_percentage || 0,
      lastAccessed: data?.last_accessed || null
    };
  } catch (error) {
    console.error('Error getting course progress:', error);
    return { success: false, progress: 0, error };
  }
};

// Fetch course content with detailed structure
export const fetchCourseContent = async (courseId: string) => {
  try {
    console.log('Fetching course content for course:', courseId);
    
    // First get the course details
    const { data: courseData, error: courseError } = await supabase
      .from('courses')
      .select('*')
      .eq('id', courseId)
      .single();
      
    if (courseError) {
      console.error('Error fetching course details:', courseError);
      throw courseError;
    }
    
    if (!courseData) {
      console.log('No course found with ID:', courseId);
      return null;
    }
    
    // Then get chapters for the course
    const { data: chaptersData, error: chaptersError } = await supabase
      .from('chapters')
      .select('*')
      .eq('course_id', courseId)
      .order('order_index', { ascending: true });
      
    if (chaptersError) {
      console.error('Error fetching chapters:', chaptersError);
      throw chaptersError;
    }
    
    // Now get all lessons for the course
    const { data: lessonsData, error: lessonsError } = await supabase
      .from('lessons')
      .select('*')
      .eq('course_id', courseId)
      .order('order_index', { ascending: true });
      
    if (lessonsError) {
      console.error('Error fetching lessons:', lessonsError);
      throw lessonsError;
    }
    
    // Get all chapter tests
    const { data: testsData, error: testsError } = await supabase
      .from('chapter_tests')
      .select('*')
      .eq('chapter_id', chaptersData.map(chapter => chapter.id)[0]);  // FIX: Changed string[] to string by taking first chapter
      
    if (testsError) {
      console.error('Error fetching chapter tests:', testsError);
      // Don't throw here, just log the error and continue without test data
    }
    
    // Now organize lessons by chapter
    const structuredChapters = chaptersData.map(chapter => {
      const chapterLessons = lessonsData.filter(lesson => lesson.chapter_id === chapter.id);
      const chapterTests = testsData?.filter(test => test.chapter_id === chapter.id) || [];
      
      return {
        ...chapter,
        lessons: chapterLessons,
        tests: chapterTests
      };
    });
    
    // Return structured course content
    return {
      ...courseData,
      chapters: structuredChapters
    };
    
  } catch (error) {
    console.error('Error fetching course content:', error);
    return null;
  }
};

// Tối ưu hóa hàm fetchCourseTests để cải thiện hiệu suất
export const fetchCourseTests = async (courseId: string) => {
  try {
    console.log('Fetching course tests for course:', courseId);
    
    // Fetch test info with single query containing both tests and questions
    const { data: testsData, error: testsError } = await supabase
      .from('course_tests')
      .select(`
        *,
        questions:course_test_questions(*)
      `)
      .eq('course_id', courseId);
      
    if (testsError) {
      console.error('Error fetching course tests:', testsError);
      throw testsError;
    }
    
    if (!testsData || testsData.length === 0) {
      console.log('No tests found for course:', courseId);
      return [];
    }
    
    console.log('Successfully fetched tests data:', testsData.length);
    return testsData;
  } catch (error) {
    console.error('Error fetching course tests:', error);
    return [];
  }
};
